# -*- coding: utf-8 -*-
"""Toronto_March 28  Aranan_LSTM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T8T3LY0mUHA_OquI2ub0Xugi_edC_2FL
"""

import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from sklearn.metrics import mean_squared_error
import plotly.graph_objects as go

!pip install meteostat
import re
import urllib.request
api_url = 'https://raw.githubusercontent.com/tanmayyb/ele70_bv03/refs/heads/main/api/datasets.py'
exec(urllib.request.urlopen(api_url).read())

ieso = IESODataset('zonal')

target_options = ieso.get_target_options() # returns list of the target options
available_dates = ieso.get_dates() # returns list of available dates (str)


print(target_options)
print(available_dates)

target_val = 4
ieso.set_target(target_val)
ieso.load_dataset(start_date='2010', end_date='2020', download=True)

climate = ClimateDataset(ieso)
climate.load_dataset(sample_num=5, download=True)

preprocessor = DatasetPreprocessor(ieso, climate)
target_name, dataset, dt = preprocessor.preprocess()

(X_train, X_test, y_train, y_test), (train_idx, test_idx) = create_train_test_split(dataset, target=target_name, dt=dt)
y_test_numpy = y_test.to_numpy()

import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import LSTM, Dense


data = dataset


scaler = MinMaxScaler(feature_range=(0, 1))
data_scaled = scaler.fit_transform(data)

train_size = int(len(data_scaled) * 0.80)
train_data, test_data = data_scaled[:train_size], data_scaled[train_size:]


def create_dataset(dataset, look_back=1):
    X, Y = [], []
    for i in range(len(dataset) - look_back -1):
        a = dataset[i:(i + look_back), 0]
        X.append(a)
        Y.append(dataset[i + look_back, 0])
    return np.array(X), np.array(Y)

look_back = 6
X_train, Y_train = create_dataset(train_data, look_back)
X_test, Y_test = create_dataset(test_data, look_back)


X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))
X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))

model = Sequential()
model.add(LSTM(units=25, return_sequences=True, input_shape=(X_train.shape[1], 1)))
model.add(LSTM(units=25))
model.add(Dense(1))

model.compile(loss='mean_squared_error', optimizer='adam')


model.fit(X_train, Y_train, epochs=40, batch_size=900, verbose=0)


train_predict = model.predict(X_train)
test_predict = model.predict(X_test)


train_predict = scaler.inverse_transform(np.concatenate((train_predict, np.zeros((len(train_predict), len(data.columns) - 1))), axis=1))[:, 0]
Y_train = scaler.inverse_transform(np.concatenate((Y_train.reshape(-1, 1), np.zeros((len(Y_train), len(data.columns) - 1))), axis=1))[:, 0]
test_predict = scaler.inverse_transform(np.concatenate((test_predict, np.zeros((len(test_predict), len(data.columns) - 1))), axis=1))[:, 0]
Y_test = scaler.inverse_transform(np.concatenate((Y_test.reshape(-1, 1), np.zeros((len(Y_test), len(data.columns) - 1))), axis=1))[:, 0]

import numpy as np
from sklearn.metrics import mean_absolute_error, mean_squared_error


mse = mean_squared_error(Y_test, test_predict)
print(f'Mean Squared Error (MSE): {mse}')


mae = mean_absolute_error(Y_test, test_predict)
print(f'Mean Absolute Error (MAE): {mae}')


mape = np.mean(np.abs((Y_test - test_predict) / Y_test)) * 100
print(f'Mean Absolute Percentage Error (MAPE): {mape:.2f}%')

#@markdown plot prediction
fig = go.Figure()
fig.add_trace(go.Scattergl(
    x=dt[train_size + look_back + 1:][:len(Y_test)],
    y=Y_test,
    name='Actual',
    line_color='blue')
)

fig.add_trace(go.Scattergl(
    x=dt[train_size + look_back + 1:][:len(Y_test)],
    y=test_predict,
    name='Predicted',
    line_color='red')
)

# Set the theme to 'plotly_white'
fig.update_layout(
    title=f"Time Series Forecasting for with LSTM in {target_name}",
    xaxis_title="Date", # Change the x-axis title
    yaxis_title="Energy Demand",
    template="plotly_white",
    xaxis = dict(
      rangeslider=dict(
          visible=True
      ),
      tickformat="%Y-%m-%d"
    )
)
fig.show()

tmp = pd.concat([dt[train_size + look_back + 1:][:len(test_predict)],
                 y_test[:len(test_predict)],
                 pd.Series(test_predict, index=y_test[:len(test_predict)].index, name='pred')],
                axis=1).dropna()

tmp['error'] = tmp[target_name] - tmp['pred']
tmp['abs_error'] = tmp['error'].apply(np.abs)

worst_predicted = tmp.sort_values(by='abs_error', ascending=False)
worst_predicted[:10]

best_predicted = tmp.sort_values(by='abs_error', ascending=True)
best_predicted[:10]

best_predicted.iloc[:168].sort_index()

#@markdown plot best/worst predictions
from plotly.subplots import make_subplots

hours = 168*10 # hours in a week
sorted_best_predicted = best_predicted.iloc[:hours].sort_index()
sorted_worst_predicted = worst_predicted.iloc[:hours].sort_index()


fig = make_subplots(rows=2, cols=1, shared_xaxes=True, subplot_titles=(f'Best Predicted Hours for {target_name}',f'Worst Predicted Hours for {target_name}'))

# best predicted
fig.append_trace(go.Scattergl(
    x=sorted_best_predicted.DateTime,
    y=sorted_best_predicted[target_name],
    name='Target',
    mode='markers',
    # line_color='blue'
), row=1, col=1)

fig.append_trace(go.Scattergl(
    x=sorted_best_predicted.DateTime,
    y=sorted_best_predicted[target_name],
    name='Predicted',
    line_color='red'
), row=1, col=1)


# worst predicted
fig.append_trace(go.Scattergl(
    x=sorted_worst_predicted.DateTime,
    y=sorted_worst_predicted[target_name],
    name='Target',
    mode='markers',
    # line_color='blue'
), row=2, col=1)

fig.append_trace(go.Scattergl(
    x=sorted_worst_predicted.DateTime,
    y=sorted_worst_predicted.pred,
    name='Predicted',
    line_color='red'
), row=2, col=1)


fig.update_layout(
    title=f"Best/Worst Predictions for: {target_name}",

    # yaxis_title="Energy Demand",
    template="plotly_white",
)

fig.update_xaxes(
    title="t (1 unit = 1 hour)",
    rangeslider_visible=True, row=2, col=1)


fig.show()

# ipython-input-195-3ed81542a0a7
from google.colab import drive
drive.mount('/content/drive')

tmp.to_csv('/content/drive/My Drive/' + 'lstm_Model_.csv', index=False)