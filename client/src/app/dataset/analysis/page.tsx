"use client";

import React, { useState, useContext } from "react";
import { useRouter } from "next/navigation";
import {
  Box,
  Button,
  Grid,
  Typography,
  Paper,
  CircularProgress,
} from "@mui/material";
import axios from "axios";
import Image from "next/image";
import { CsvContext } from "@/context/CsvContext"; // Assuming this context provides the CSV data

interface XgbResult {
  train_loss: number;
  test_loss: number;
  train_accuracy: number;
  test_accuracy: number;
  loss_curve: string;         // base64-encoded image (Train/Test RMSE vs Epoch)
  performance_plot: string;   // base64-encoded image (Actual vs Pred over Time)
  anomaly_csv: string;        // CSV string for anomaly detection input
  target_column_used: string; // The target column name inferred by the backend
}

interface LstmResult {
  train_loss: number; // Changed from number | null, assuming backend always calculates it
  test_loss: number;
  train_accuracy: number; // Changed from number | null
  test_accuracy: number;
  loss_curve: string;             // base64-encoded image (Train/Validation RMSE vs Epoch) - RENAMED from train_loss_curve
  performance_plot: string;       // base64-encoded image (Actual vs Pred over Time Test) - RENAMED from test_predictions_plot
  anomaly_csv: string;            // CSV string for anomaly detection input
  target_column_used: string;     // The target column name inferred by the backend
}


export default function AnalysisPage() {
  // Use CsvContext to get the CSV data generated in the previous step
  const { csvData, setCsvData } = useContext(CsvContext);
  const [xgbResult, setXgbResult] = useState<XgbResult | null>(null);
  const [lstmResult, setLstmResult] = useState<LstmResult | null>(null);
  const [loadingXgb, setLoadingXgb] = useState(false); // Separate loading states
  const [loadingLstm, setLoadingLstm] = useState(false); // Separate loading states
  const [error, setError] = useState("");

  const router = useRouter();
  // No longer need to explicitly get targetColumn to send to backend

  // Handler for running only the XGBoost model
  const handleRunXGB = async () => {
    // Check if the 'original' CSV data exists in the context
    if (!csvData || !csvData.original) {
      setError("No CSV data found. Please generate data in the previous step.");
      return;
    }
    setError("");
    setLoadingXgb(true); // Start loading for XGB
    setXgbResult(null); // Clear previous results
    try {
      // Create a Blob from the CSV string stored in context
      const blob = new Blob([csvData.original], { type: "text/csv" });
      const formData = new FormData();
      formData.append("file", blob, "input_data.csv"); // Use a generic filename
      // REMOVED: formData.append("target", targetColumn); // Target is now inferred by backend

      const response = await axios.post<XgbResult>("http://localhost:5000/xgb", formData, {
        headers: { "Content-Type": "multipart/form-data" },
      });

      setXgbResult(response.data);
      // Store the anomaly CSV generated by XGBoost in the context under the 'xgb' key
      setCsvData((prev) => ({ ...prev, xgb: response.data.anomaly_csv }));
    } catch (err: any) { // Catch specific error types if possible
      console.error("XGBoost Error:", err);
      setError(err.response?.data?.error || err.message || "Error running XGBoost model.");
    } finally {
      setLoadingXgb(false); // Stop loading for XGB
    }
  };

  // Handler for running only the LSTM model
  const handleRunLSTM = async () => {
    // Check if the 'original' CSV data exists in the context
    if (!csvData || !csvData.original) {
      setError("No CSV data found. Please generate data in the previous step.");
      return;
    }
    setError("");
    setLoadingLstm(true); // Start loading for LSTM
    setLstmResult(null); // Clear previous results
    try {
       // Create a Blob from the CSV string stored in context
      const blob = new Blob([csvData.original], { type: "text/csv" });
      const formData = new FormData();
      formData.append("file", blob, "input_data.csv"); // Use a generic filename
      // REMOVED: formData.append("target", targetColumn); // Target is now inferred by backend

      // Assuming the backend might have renamed the result fields for consistency
      const response = await axios.post<LstmResult>("http://localhost:5000/lstm", formData, {
        headers: { "Content-Type": "multipart/form-data" },
      });

      // Map backend response names to frontend state names if they differ
      const mappedResult: LstmResult = {
        ...response.data,
        // Ensure the names match the LstmResult interface
        // If backend returns 'train_loss_curve', map it here if needed, but ideally align names.
        // Backend seems to return 'loss_curve' and 'performance_plot' now for both models.
        // Assuming backend response keys match LstmResult interface.
      };

      setLstmResult(mappedResult);
       // Store the anomaly CSV generated by LSTM in the context under the 'lstm' key
      setCsvData((prev) => ({ ...prev, lstm: mappedResult.anomaly_csv }));
    } catch (err: any) {
      console.error("LSTM Error:", err);
      setError(err.response?.data?.error || err.message || "Error running LSTM model.");
    } finally {
      setLoadingLstm(false); // Stop loading for LSTM
    }
  };

  // Navigate to the next step (Anomaly Detection)
  const handleNext = () => {
    // Check if at least one model has run and produced anomaly data
    if (!csvData?.xgb && !csvData?.lstm) {
        setError("Please run at least one model (XGBoost or LSTM) before proceeding to anomaly detection.");
        return;
    }
    setError(""); // Clear error if navigation is successful
    router.push("/dataset/anomaly"); // Navigate to the anomaly detection page
  };

  // Navigate back to the previous step
  const handleBack = () => {
    router.back();
  };

  return (
    <Box
      sx={{
        minHeight: "100vh",
        backgroundColor: "black",
        color: "white",
        p: 2,
        display: "flex", // Added for centering content vertically
        flexDirection: "column", // Stack items vertically
      }}
    >
      {/* Header */}
      <Box sx={{ textAlign: "center", mb: 3 }}>
        <Typography variant="h5" sx={{ fontWeight: 'bold' }}>
          #4 Model Training & Analysis
        </Typography>
        <Typography variant="body1" sx={{ color: 'grey.400' }}>
          Train XGBoost and LSTM models using the generated dataset.
        </Typography>
      </Box>

       {/* Error Display */}
      {error && (
        <Typography variant="body1" color="error" sx={{ mb: 2, textAlign: 'center' }}>
          {error}
        </Typography>
      )}

      {/* Run Buttons and Loaders */}
      <Box
        sx={{
          display: "flex",
          justifyContent: "center",
          alignItems: 'center', // Align items vertically in the center
          gap: 3, // Increased gap
          mb: 4, // Increased margin bottom
        }}
      >
        <Box sx={{ position: 'relative', display: 'inline-flex' }}>
          <Button
            variant="contained"
            color="primary" // Keep distinct colors or make them consistent
            onClick={handleRunXGB}
            disabled={loadingXgb || loadingLstm} // Disable if either is loading
            sx={{ fontSize: "1.1rem", padding: "10px 20px" }} // Adjusted size
          >
            Run XGBoost
          </Button>
          {loadingXgb && (
            <CircularProgress
              size={24}
              color="inherit" // White progress indicator
              sx={{
                position: 'absolute',
                top: '50%',
                left: '50%',
                marginTop: '-12px',
                marginLeft: '-12px',
              }}
            />
          )}
        </Box>

        <Box sx={{ position: 'relative', display: 'inline-flex' }}>
          <Button
            variant="contained"
            color="secondary" // Keep distinct colors or make them consistent
            onClick={handleRunLSTM}
            disabled={loadingXgb || loadingLstm} // Disable if either is loading
            sx={{ fontSize: "1.1rem", padding: "10px 20px" }} // Adjusted size
          >
            Run LSTM
          </Button>
          {loadingLstm && (
            <CircularProgress
              size={24}
              color="inherit" // White progress indicator
              sx={{
                position: 'absolute',
                top: '50%',
                left: '50%',
                marginTop: '-12px',
                marginLeft: '-12px',
              }}
            />
          )}
        </Box>
      </Box>


      {/* Results Area */}
      <Grid container spacing={3} alignItems="stretch" sx={{ flexGrow: 1 }}> {/* Allow grid to grow */}
        {/* Left Column: Graphs */}
        <Grid item xs={12} md={8}> {/* Adjusted grid size */}
          <Grid container spacing={3}> {/* Nested grid for graph spacing */}
            {xgbResult && (
              <>
                <Grid item xs={12}> {/* Full width for each XGB graph section */}
                  <Paper sx={{ backgroundColor: "#222", color: "white", p: 2 }}>
                    <Typography variant="h6" sx={{ mb: 1, textAlign: 'center' }}>
                      XGBoost Loss Curve (Target: {xgbResult.target_column_used})
                    </Typography>
                    <Box sx={{ display: 'flex', justifyContent: 'center' }}>
                      <Image
                        src={`data:image/png;base64,${xgbResult.loss_curve}`}
                        alt="XGB Loss Curve"
                        unoptimized
                        width={700} // Fixed width for consistency
                        height={350} // Fixed height
                        style={{ objectFit: "contain" }} // Contain maintains aspect ratio
                      />
                    </Box>
                  </Paper>
                </Grid>
                <Grid item xs={12}>
                  <Paper sx={{ backgroundColor: "#222", color: "white", p: 2 }}>
                    <Typography variant="h6" sx={{ mb: 1, textAlign: 'center' }}>
                      XGBoost Performance (Target: {xgbResult.target_column_used})
                    </Typography>
                     <Box sx={{ display: 'flex', justifyContent: 'center' }}>
                        <Image
                          src={`data:image/png;base64,${xgbResult.performance_plot}`}
                          alt="XGB Performance Plot"
                          unoptimized
                          width={700}
                          height={350}
                          style={{ objectFit: "contain" }}
                        />
                    </Box>
                  </Paper>
                </Grid>
              </>
            )}

            {lstmResult && (
              <>
                <Grid item xs={12}>
                  <Paper sx={{ backgroundColor: "#222", color: "white", p: 2 }}>
                    <Typography variant="h6" sx={{ mb: 1, textAlign: 'center' }}>
                      LSTM Loss Curve (Target: {lstmResult.target_column_used})
                    </Typography>
                     <Box sx={{ display: 'flex', justifyContent: 'center' }}>
                        <Image
                          // Use loss_curve if backend aligned names, otherwise map if needed
                          src={`data:image/png;base64,${lstmResult.loss_curve}`}
                          alt="LSTM Loss Curve"
                          unoptimized
                          width={700}
                          height={350}
                          style={{ objectFit: "contain" }}
                        />
                    </Box>
                  </Paper>
                </Grid>
                <Grid item xs={12}>
                  <Paper sx={{ backgroundColor: "#222", color: "white", p: 2 }}>
                    <Typography variant="h6" sx={{ mb: 1, textAlign: 'center' }}>
                       LSTM Performance (Target: {lstmResult.target_column_used})
                    </Typography>
                     <Box sx={{ display: 'flex', justifyContent: 'center' }}>
                        <Image
                          // Use performance_plot if backend aligned names, otherwise map if needed
                          src={`data:image/png;base64,${lstmResult.performance_plot}`}
                          alt="LSTM Performance Plot"
                          unoptimized
                          width={700}
                          height={350}
                          style={{ objectFit: "contain" }}
                        />
                    </Box>
                  </Paper>
                </Grid>
              </>
            )}
            {!xgbResult && !lstmResult && !loadingXgb && !loadingLstm && (
                 <Grid item xs={12}>
                    <Paper sx={{ backgroundColor: "#222", color: "grey.500", p: 2, textAlign: 'center', height: '200px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                        <Typography variant="h6">Run a model to view results here.</Typography>
                    </Paper>
                </Grid>
             )}
          </Grid>
        </Grid>

        {/* Right Column: Metrics */}
        <Grid item xs={12} md={4}> {/* Adjusted grid size */}
          <Grid container spacing={3} direction="column"> {/* Stack metrics vertically */}
            {xgbResult && (
              <Grid item>
                <Paper sx={{ backgroundColor: "#222", color: "white", p: 2, height: '100%' }}>
                  <Typography variant="h6" sx={{ mb: 1 }}>
                    XGBoost Metrics
                  </Typography>
                  <Typography variant="body2">Target Column: {xgbResult.target_column_used}</Typography>
                  <Typography variant="body2">Train RMSE: {xgbResult.train_loss.toFixed(4)}</Typography>
                  <Typography variant="body2" sx={{ fontWeight: 'bold' }}>
                    Test RMSE: {xgbResult.test_loss.toFixed(4)}
                  </Typography>
                  <Typography variant="body2">Train R²: {xgbResult.train_accuracy.toFixed(4)}</Typography>
                  <Typography variant="body2" sx={{ fontWeight: 'bold' }}>
                    Test R²: {xgbResult.test_accuracy.toFixed(4)}
                  </Typography>
                </Paper>
              </Grid>
            )}

            {lstmResult && (
              <Grid item>
                <Paper sx={{ backgroundColor: "#222", color: "white", p: 2, height: '100%' }}>
                  <Typography variant="h6" sx={{ mb: 1 }}>
                    LSTM Metrics
                  </Typography>
                  <Typography variant="body2">Target Column: {lstmResult.target_column_used}</Typography>
                   {/* Display metrics - ensure names match interface */}
                   <Typography variant="body2">Train RMSE: {lstmResult.train_loss.toFixed(4)}</Typography>
                  <Typography variant="body2" sx={{ fontWeight: 'bold' }}>
                    Test RMSE: {lstmResult.test_loss.toFixed(4)}
                  </Typography>
                  <Typography variant="body2">Train R²: {lstmResult.train_accuracy.toFixed(4)}</Typography>
                  <Typography variant="body2" sx={{ fontWeight: 'bold' }}>
                    Test R²: {lstmResult.test_accuracy.toFixed(4)}
                  </Typography>
                </Paper>
              </Grid>
            )}
             {/* Placeholder if no results yet */}
             {!xgbResult && !lstmResult && !loadingXgb && !loadingLstm && (
                 <Grid item xs={12}>
                    <Paper sx={{ backgroundColor: "#222", color: "grey.500", p: 2, textAlign: 'center', height: '200px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                        <Typography variant="h6">Run a model to view results here.</Typography>
                    </Paper>
                </Grid>
             )}
          </Grid>
        </Grid>
      </Grid>


      {/* Navigation Buttons */}
      <Box display="flex" justifyContent="center" alignItems="center" mt="auto" pt={4} gap={3}> {/* Pushes buttons down */}
        <Button
          variant="outlined"
          color="inherit"
          onClick={handleBack}
          size="large"
          sx={{ fontSize: "1.1rem", padding: "10px 20px" }} // Adjusted size
        >
          BACK
        </Button>
        <Button
          variant="contained" // Changed to contained for emphasis
          color="success"     // Use a success color for NEXT
          onClick={handleNext}
          disabled={!csvData?.xgb && !csvData?.lstm} // Disable if no anomaly data is ready
          size="large"
          sx={{ fontSize: "1.1rem", padding: "10px 20px" }} // Adjusted size
        >
          NEXT: Anomalies
        </Button>
      </Box>
    </Box>
  );
}